On Error Resume Next
'******************************************************************************************
'************************************ DiskHealth.vbs v1.71  ********************************
'****************************      Written By: Brian Shackelford **************************
'****************************       Date: September 20th, 2011  ***************************
'****************************   Copyright Data Network Services, Inc. *********************
'***  WARNING: This script should only be run by a Microsoft certified Administrator   ****
'** Data Network Services, Incs presents this script AS-IS - use at your own discretion ***
'******************************************************************************************
'******************************************************************************************
' DiskHealth.vbs Script written by Brian A. Shackelford @ Data Network Services, Inc.  Please
' feel free to use / copy / modify this script to suit your needs - BUT keep credits within
' your code where credits are due.  A LOT of time when into creating this script and a lot
' of conflict went into providing as a free tool for N-Able Partners to use, but at the 
' conference I realized that there were a lot of folks that could use this and do NOT have
' internal folks to create something like this.
'
' I also included the cleanup script generated by Chris Reid in here as well.  A lot of 
' resources were used to find the information needed to do these tasks in vbscript.
'
' So here it is for anyone who would like to be used as desired by our N-Able MSP
' partner friends on ONE condition.  If you modify this software to do more, do something
' it currently does not do, do anything to make it better, it needs to be released to the
' N-Able community as well.  
'
' This "little" program was a little over a year in the making in my spare time and lots 
' of research and learning went into it.  It has been tested on Windows XP, 2003, Vista, 
' 7, 2008, 2008 R2 under both 32 bit and 64 bit editions.
' 
' If you wish for additional features to be added, please feel free to share those with me.
' Depending on time and how hard it would be to implement, I will work on adding them.  
' The three missing features I am currently working on are:
'
' 1.  Safely cleanup Temp Files from All Profiles on a system (based on location determined
'     by the registry - not just going out and looking for folders.
'
' 2.  Deleting local profiles on a system that have not been accessed in a period of time and
' 	  providing a list back to N-Able of which profiles were cleaned up.  I am unsure if Powershell
'     or vbs is the best way to go with this.  Both present challenges - ESPECIALLY with redirected
'     profiles.  Need to test if it just deletes the local files or if it actually goes out and
'	  removes the redirected profiles as well.  Additionally - as you can see in other portions
'	  of the program - it is written to use .VBS where we could have used Powershell.  Reasoning
'	  for this in our case is that A LOT of users still run XP that we manage and powershell cannot
'	  do some of the functions on XP that can be done on Vista and higher.
'
' 3.  Find a way to email a results log with perhaps a delimited format for those who wish
'	  to run this script on unmanaged clients or clients with just essential licenses.  Perhaps
'     this will require a seperate .NET app to perform and I will need to capture some computer
'	  information along with it.  This would make it easier to setup as a scheduled task in
'     the windows itself and send a log file to check to a tech.  This might be useful for
'     MSP's with lots of customers using Essential licenses to get notified if a disk is about
' 	  to fail.  The great part of that is that it would probably lead to selling them on a fully
'	  managed solution if just one incident of failure is predicted and prevented.
' 
' So far the top two of these items are somehwat working - although with "interesting" results on 
' my local test box.  If anyone would like to help with these items, let me know.  I have a small
' C# .NET app that can do the third, but still trying to decide if it is worth it or not.
'
' A guide on using this script will be coming out shortly as well, but for now just read the comments
' as they are pretty self explanatory.  
'
' My contact informaiton:
'
' Brian Shackelford
' Data Network Services, Inc.
' P.O. Box 1683
' Richmond, VA 23230
' Phone: (804) 359 - 1633
' Fax: (804) 359 - 8714
' Email: brian@dns-net.com
' Secondary E-mail: bshackelford@itsnippets.com
'
' DiskHealth.vbs script
'
' Start of Script Configuration
' ****************************************************************************************
Dim bRunDefragScript
Dim bRunCleanup
Dim bCheckFragmentation
Dim bForceDefrag

'*****************************************************************************************
' Set the Script to Perform the Required Actions based on the options below.  Note that
' setting some options will override other preferences to ensure that everything is logged
' correctly and that no errors are evident before running.  An Example is if bRunDefragScript
' is set to True then it will force the ChkDsk and the Defrag Analysis Regardless of their
' Settings.  If all options are set to false, then it will only perform the chkdsk.
' ****************************************************************************************
bRunDefragScript = False 'Enable / Disable Defrag - Enable or Disable Defragmentation of the drive
bRunCleanup = False 'Enable / Disable Disk Cleanup - Runs Chris Reid's cleanup script
bCheckFragmentation = False 'Enable / Disable Disk Fragmentation Checking - If Defrag is enabled, this setting is ignored
bForceDefrag = False 'Force Defrag Even if it is Below the FragPercentRequireBeforeDefrag - If Defrag is disabled, this setting is ignored

' ****************************************************************************************
' Setup Some Constants for use in the Script. 
' ****************************************************************************************
Const strScriptVersion = "1.71" ' Will be used by Namespace, Class and Instance Methods 
Const wbemCimtypeUint32 = 19
Const wbemCimtypeString = 8
Const wbemCimtypeBoolean = 11
Const wbemCimtypeSint32 = 3
Const wbemFlagReturnImmediately = &h10
Const wbemFlagForwardOnly = &h20
Const dfAnalysisCmd = "cmd /c defrag /a /v " ' Note this is missing the drive letter - has to be added by script
Const ForReading = 1
Const ForWriting = 2
Const TemporaryFolder = 2 ' Constant Needed for fso to determine the %TEMP%
Const DeleteReadOnly = TRUE
Const HKEY_LOCAL_MACHINE = &H80000002
Const SIDExclusionList = "|S-1-5-18|S-1-5-19|S-1-5-20|"

'*****************************************************************************************
' Setup the commands and options to be used for running the defrag 
' ****************************************************************************************
Const FragPercentRequiredBeforeDefrag = 15 ' Frag Percentage Needed before the Defrag will Run
Const x64DefragCmd = "c:\windows\system32\udefrag.exe" ' Note this is missing the drive letter - has to be added by script
Const x86DefragCmd = "c:\windows\system32\udefrag.exe" ' Note this is missing the drive letter - has to be added by script
Const x64DefragCmdOptions = " --defragment " ' Defrag Command Line Options
Const x86DefragCmdOptions = " --defragment " ' Defrag Command Line Options

'*****************************************************************************************
' Setup the Custom Namespace and Class to be used to store the various results in WMI.
' Note that the classes are used by the Monitoring Service, so once you start deploying
' and using the script it is NOT recommended to make any changes to the NameSpace unless
' you are planning to redo the custom service as well.  If you make ANY changes to the 
' variables stored in WMI, also be sure the change the script version number variable 
' called strScriptVersion.  This will cause the WMI class to be deleted and recreated.
' ****************************************************************************************
Const uNameSpace = "NableEnhancements" ' Custom Namespace you want to create / use to store Information
Const uClass = "Disk_Health" ' Custom Class you want to store the Info in for WMI

'*****************************************************************************************
' Set the MaxNumDrives to run the script against.  Since there are only 26 letters of the
' alphabet, I start off with a Max of 26
' ****************************************************************************************
Const MaxNumDrives = 26 ' Maximum Number of Drives This Script will Handle

'*****************************************************************************************
' Set ChkDsk to run in read-only or to fix errors found.  If errors are found and the drive
' cannot be locked, it will flag the drive to be checked on next boot.  Not recommended unless
' you choose to run the chkdsk in fix mode to remedy a problem found in monitoring.
' ****************************************************************************************
Const FIX_ERRORS = False ' When doing the disk check, do not attempt to fix problems

'*****************************************************************************************
' Declare some vars for use in the script. 
'*****************************************************************************************
Dim strComputer ' Used when accessing WMI
Dim objShell ' Used when needing to Run a Shell Command (Such as defrag...)
Dim oShellCmd ' String Used to Hold Path / Command to Run in the obSjell
Dim objFSO ' Filesystem Object to Read / Write / Delete Files and Folders
Dim objFile ' File object to Read / Write / Delete File
Dim oBeforeResults
Dim oAfterResults
Dim oDefragResults
Dim oFinalStats(6)
Dim oTimeStart 
Dim oTimeStop
Dim oFragStart
Dim oFragStop
Dim isSuccess 
Dim oCommandUsed
Dim oFreeSpaceBefore 
Dim oFreeSpaceAfter 
Dim oCleanCommandUsed
Dim oCheckDiskResults
Dim oNumErrorsOccurredInScript 


'*****************************************************************************************
' Set some default values so the WMI monitoring service will not error out when looking
' for the data.  Please let me know any thoughts you might have on the monitoring service
' or default values so as to assist in getting at the best information to assist folks
' in getting a handle on the overal volume health on a system.  Also open to changin / 
' modifying any of the information below.
'****************************************************************************************
oBeforeResults = "0"
oAfterResults = "0"
oDefragResults = "0"
oTimeStart = "January 1, 1900 12:00:00 AM"
oTimeStop = "January 1, 1900 12:00:00 AM"
oFragStart = 0
oFragStop = 0
isSuccess = True
oCommandUsed = "Not Run"
oFreeSpaceBefore = "0"
oFreeSpaceAfter = "0" 
oCleanCommandUsed = "Not Run"
oCheckDiskResults = "0"
oNumErrorsOccurredInScript = "0"

strComputer = "."
Set ParentWMINamespace = GetObject("winmgmts:\\" & strComputer & "\root")

If bRunDefragScript = True Then
	bRunCheckFragmentation = True
End If

'*****************************************************************************************
' Function to  Determine whether this is a x64 
' or x32 system for use Later In the Script.
'*****************************************************************************************
Function CheckArchitecture()
 Dim intAddressWidth ' Used to Hold the Type of Processor used (x64 or x86)
 Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")
 Set colProcessors = objWMIService.ExecQuery("Select * from Win32_Processor") 'Query WMI to find the Processors

 For Each objProcessor in colProcessors ' Loop through the Processors 
  intAddressWidth = objProcessor.AddressWidth ' Set the Processor Type (32 or 64)
 Next
 CheckArchitecture = intAddressWidth ' Return the Processor Type
End Function


'*****************************************************************************************
' Function to Determine What Version of Windows is Running
' so that the correct Analasys can be run on the defrag
' output file.
'*****************************************************************************************
Function CheckOS()
 Set objWshShell = Wscript.CreateObject("WScript.Shell")
 Set objWMI = GetObject("winmgmts:\\" & strComputer & "\root\CIMV2")
 Set colItems = objWMI.ExecQuery("SELECT Caption FROM Win32_OperatingSystem", "WQL", wbemFlagReturnImmediately + wbemFlagForwardOnly)

 For Each objItem In colItems
         If InStr(objItem.Caption, "XP") > 0 Then
                  oStrOS = "Classic"
             ElseIf (InStr(objItem.Caption, "Vista") Or InStr(objItem.Caption, "2003") Or InStr(objItem.Caption, "2008") Or InStr(objItem.Caption, "Windows 7")) > 0 Then
                  oStrOS = "New"
            End If
        Next
 CheckOS = oStrOS
End Function

'*****************************************************************************************
' Function to Do the Fragmentation Analysis.  Note that this uses Windows built in defrag utility
' and writes a defrag.txt TMP file to the %TEMP% system Variable folder.  It returns an Array
' Contatining Values:
' [0] = Percent Fragmentation
' [1] = Needs to be Defragged (1 = True, 0 = False)
'
' On Windows Vista or higher we could use WMI here but for the sake of simplicity in using a single
' routine I just used the internal included Windows Defrag Utility.
'
' Portions of Code Used from:
' http://scriptzilla.blogspot.com/2009/09/windows-defrag-from-script-to-script.html
'*****************************************************************************************
Function DefragAnalysis(strDrive)
 Dim strLine 'Private for use in this Function
 Dim tFolder ' Private for use in this Function to Hold Temp Folder Path
 Dim parse ' Private for use in This Function to Hold Each Line of Parsed Data
 Dim label ' Hold the Label Text for Each Result
 Dim data ' Hold Data For Each Results
 Dim oStrAnalysisResults ' Hold String of Full Results
 Dim oFragPercent ' Hold the Numeric Value of Fragmentation Percentage
 Dim oResultsArray(2) ' Hold the Results Array

 Set objFSO   = CreateObject("Scripting.FileSystemObject")
 Set tFolder = objFSO.GetSpecialFolder(TemporaryFolder)
 Set objShell = CreateObject("Wscript.Shell")
 inputFile = tFolder & "\" & "defrag.txt"
 oStrAnalysisResults = "info: running defrag analysis on " & strDrive & vbCrLf
 objShell.Run dfAnalysisCmd & strDrive & " >" & inputFile, 1, True
 oStrAnalysisResults = oStrAnalysisResults & "info: defrag completed" & vbCrLf
 oStrAnalysisResults = oStrAnalysisResults &  "info: checking if input file was created..." & vbCrLf
 If objFSO.FileExists(inputFile) Then
     oStrAnalysisResults = oStrAnalysisResults &  "info: file was found, opening for input..." & vbCrLf
     Set objFile = objFSO.OpenTextFile(inputFile, ForReading)
     Do Until objFile.AtEndOfStream
         strLine = Trim(objFile.Readline)
         If InStr(1, strLine, "=") <> 0 Then
             strLine = Replace(strLine, vbTab, "")
             parse = Split(strLine, "=")
             label = Trim(parse(0))
             data  = Trim(parse(1))
             oStrAnalysisResults = oStrAnalysisResults & label & ": " & vbTab & data & vbCrLf
      If (InStr(label, "tal fragmentation") > 1 Or _ 
	  InStr(label, "fragmented space") > 1 Or _
	  Instr(label, "rcent file fragmentation") > 1) Then
   oFragPercent = StripAlpha(data, 1)
   oResultsArray(0) = oFragPercent
   If int(oFragPercent) >= FragPercentRequiredBeforeDefrag Then ' If frag % is equal or higher than the min % required then run the defrag
    oResultsArray(1) = 1 
   ElseIf bForceDefrag = True Then ' If force defrag is enabled return 1 
   oResultsArray(1) = 1
   Else
    oResultsArray(1) = 0 ' If frag % is lower than min % required then do not run the defrag
   End If
      End If
         End If
     Loop
     objFile.Close ' Close the text file
 Else
     oStrAnalysisResults = oStrAnalysisResults &  "fail: input file not found" ' Return an error if cannot open or read file
 End If
 objFSO.DeleteFile inputfile, True ' Delete the file
 Set objFSO = Nothing
 Set objShell = Nothing
 DefragAnalysis = oResultsArray ' Return the results
End Function


'*****************************************************************************************
' Function to Strip Non-Numeric Characters from a 
' String and Return the results.  This is used to
' Convert the Results to Plain Numbers for use
' when writing the information to the WMI Store
'*****************************************************************************************
Function StripAlpha(strReg, blnNum)
 Dim objRegExp 
 Dim objcolRegMatch
 Dim objRegMatch
 
 Set objRegExp = CreateObject("Vbscript.RegExp")
 With objRegExp
 '// Set as Global to get ALL instances
 .Global = True
 If blnNum Then
  '// \d+ Matches a digit character of any length.
  .Pattern = "[^\d]+"
 Else
  '// \D Matches a nondigit character of any length.
  .Pattern = "[^\D]+"
 End If
 End With

 StripAlpha = objRegExp.Replace(strReg, "")
End Function


'*****************************************************************************************
' Get a List of Logical drives against which to run the the script
' ****************************************************************************************
Function GetDrives()
 Dim strDrivesToExamine()
 Dim intCounter
 intCounter = 0
 Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")
 Set colDrives = objWMIService.ExecQuery("SELECT DeviceID FROM Win32_LogicalDisk WHERE DriveType='3'")
 For Each objDrive in colDrives
  If intCounter < MaxNumDrives Then
   ReDim Preserve strDrivesToExamine(intCounter)
   strDrivesToExamine(intCounter) = objDrive.DeviceID
   intCounter=intCounter+1
  End If
 Next
 GetDrives = strDrivesToExamine
End Function


' ****************************************************************************************
' Function to Run the Defrag.  This Function does a few things:
' 1 - Determine which Defrag Command to Use Based OS and Architecture
' 2 - Run the Defrag
' 3 - Return Whether the Run was successful or not
'
' ** - This Function also checks that the specified Defrag Command is Available.  If not, 
' it defaults to Windows Defrag with the /force option to run the defrag.  Thus if the 
' Command is not available, the defrag process still works.
' 
' You can specif your own Defrag command to use provided you give the correct command line
' options for it and it will accept a drive letter to determine which drive to run against.
' Feel free to experiment.  Suggestions appreciated
' ****************************************************************************************
Function RunDefrag(strDrive)
 Dim oDResults(4)
 Dim cmdText
 Dim strArchitecture
 Dim ReturnCode

 Set objFSO   = CreateObject("Scripting.FileSystemObject")

 oDResults(0) = Now()
 strArchitecture = CheckArchitecture()
 
 If strArchitecture = "32" And objFSO.FileExists(x86DefragCmd) Then
  cmdText = x86DefragCmd & x86DefragCmdOptions & strDrive
 ElseIf strArchitecture = "64" And objFSO.FileExists(x64DefragCmd) Then
  cmdText = x64DefragCmd & x64DefragCmdOptions & strDrive
 Else
  cmdText = "defrag /f /v " & strDrive
 End If
 
 Set objWshShell = Wscript.CreateObject("WScript.Shell")

 ReturnCode = objWshShell.Run(cmdText,,True)
 oDResults(3) = ReturnCode
 oDResults(2) = cmdText
 oDResults(1) = Now()
 RunDefrag = oDResults
End Function

' ****************************************************************************************
' Function to Check Free Space on the Drive.  Invoked at the beginning and end of the script
' ****************************************************************************************
Function GetFreeSpace(strDeviceId)
Dim objFreeSpace
 Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")
 Set colDisks = objWMIService.ExecQuery ("Select * from Win32_LogicalDisk Where DeviceID = '" & strDeviceId & "'")
 For Each objDisk in colDisks
     objFreeSpace = objDisk.FreeSpace
 Next
GetFreeSpace = objFreeSpace
End Function

' **********************************************************************************************************************
' Function to run ChkDsk on the Drive.  Return Codes are as follows:
' 0 = No Errors Found
' 1 = Errors Found and Fixed
' 2 = Disk cleanup, such as garbage collection, was performed, or cleanup was not performed because /f was not specified
' 3 = Could not check the disk, errors could not be fixed, or errors were not fixed because /f was not specified. 
'
' For more information visit: http://support.microsoft.com/kb/315265
'
' Script is pulled partially from Samples provided with VbsEdit
' ***********************************************************************************************************************
Function CheckDriveForErrors(strDeviceId)
Dim objErrResult
 Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")
 Set colDisks = objWMIService.ExecQuery ("Select * from Win32_LogicalDisk Where DeviceID = '" & strDeviceId & "'")
 For Each objDisk in colDisks
     objErrResult = objDisk.ChkDsk(FIX_ERRORS)
 Next
CheckDriveForErrors = objErrResult
End Function


' ****************************************************************************************
' SubRoutine to create a New Namespace.  We *might* change this to actually
' check if one exisits before eating a new one, BUT it works for now.
' Probably will not change unless there is a compelling reason to do so
' ****************************************************************************************
Sub CreateNameSpace
 Set objSWbemServices = GetObject ("winmgmts:\\" & strComputer & "\Root")

 ' Spawn a new instance of __Namespace
 Set objNewNamespace = objSWBemServices.Get ("__Namespace").SpawnInstance_ ()

 ' Set the name and save it to the repository
 objNewNamespace.Name = uNameSpace
 objNewNamespace.Put_
End Sub


' ****************************************************************************************
' SubRoutine to Delete the WMI Namespace in the event that a mismatch
' is detected in the version or the class needs to be recreated
' ****************************************************************************************
Sub DeleteNameSpace
	Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root")
	Set objItem = objWMIService.Get("__Namespace.Name='" & uNameSpace & "'")
	objItem.Delete_
End Sub

' ****************************************************************************************
' SubRoutine to create a New Class to Hold Disk stats.  We *might* change this to actually
' check if one exisits before eating a new one, BUT it works for now.
' Probably will not change unless there is a compelling reason to do so
' ****************************************************************************************

Sub CreateClass
 ' Use SWbemServices.Get with an empty parameter
 ' list to create an empty SWbemObject
 ' that can become a new class.
 Set objInstance = GetObject("winmgmts:\\" & strComputer & "\Root\" & uNameSpace).Get()

 ' Name the class and add some properties
 objInstance.SystemProperties_("__Class") = uClass
 objInstance.Properties_.Add "DriveID", wbemCimtypeString 
 objInstance.Properties_("DriveID").Qualifiers_.Add "Key", True
 objInstance.Properties_.Add "FragPercentageBefore", wbemCimtypeUint32
 objInstance.Properties_.Add "FragPercentageAfter", wbemCimtypeUint32
 objInstance.Properties_.Add "LastRunSuccessful", wbemCimtypeBoolean
 objInstance.Properties_.Add "DefragScriptVersion", wbemCimtypeString
 objInstance.Properties_("DefragScriptVersion").Value = strScriptVersion
 objInstance.Properties_.Add "DefragStartTime", wbemCimtypeString 
 objInstance.Properties_.Add "DefragEndTime", wbemCimtypeString 
 objInstance.Properties_.Add "CommandUsed", wbemCimtypeString
 objInstance.Properties_.Add "FreeSpaceBefore", wbemCimtypeString  
 objInstance.Properties_.Add "FreeSpaceAfter", wbemCimtypeString
 objInstance.Properties_.Add "CleanupCommandUsed", wbemCimtypeString
 objInstance.Properties_.Add "CheckDiskResults", wbemCimtypeUint32
 objInstance.Properties_.Add "ScriptReturnCode", wbemCimtypeUint32
 objInstance.Properties_.Add "DiskSpaceCleanedUp", wbemCimtypeSint32
 objInstance.Properties_.Add "FragPercentEliminated", wbemCimtypeSint32
 objInstance.Put_
End Sub

' ****************************************************************************************
' Function to Check if the Class Version is Current.
' ****************************************************************************************
Function WMIClassVersionCurrent
 Dim isCurrent
 isCurrent = vbFalse
 Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\" & uNameSpace)
 Set colDrives = objWMIService.ExecQuery("SELECT * FROM " & uClass)
 For Each objDrive in colDrives 
 	If objDrive.DefragScriptVersion = strScriptVersion Then
 	isCurrent = vbTrue
	End If
 Next
 WMIClassVersioNCurrent = isCurrent
 End Function 
 
' ****************************************************************************************
' Function to Check if the WMI NameSpace Exists Already
'  
' Function: WMINamespaceExists
' Thanks to http://www.cruto.com/resources/vbscript/vbscript-examples/misc/wmi/List-All-WMI-Namespaces.asp for this code 
' ****************************************************************************************
Function WMINamespaceExists
 WMINamespaceExists = vbFalse
 Set colNamespaces = ParentWMINamespace.InstancesOf("__Namespace")
  For Each objNamespace In colNamespaces
   If instr(objNamespace.Path_.Path,uNameSpace) Then
    WMINamespaceExists = vbTrue
   End if
  Next
 Set colNamespaces = Nothing
End Function

' ****************************************************************************************
' Function to Check if WMI Class Exist Already
'
' Function: WMIClassExists
' Thanks to http://gallery.technet.microsoft.com/ScriptCenter/en-us/a1b23364-34cb-4b2c-9629-0770c1d22ff0 for this code 
' ****************************************************************************************
Function WMIClassExists
                WMIClassExists = vbFalse
                Set WMINamespace = GetObject("winmgmts:\\" & strComputer & "\root\" & uNameSpace)
                Set colClasses = WMINamespace.SubclassesOf()
                For Each objClass In colClasses
                      If instr(objClass.Path_.Path, uClass) Then
                            WMIClassExists = vbTrue
                      End if
                Next
                Set colClasses = Nothing
End Function

'******************************************************************************************
'Script from Chris @ N-Able to Do Disk Cleanup.  DOES NOT do all user profiles, but does cleanup a 
'lot of other junk from the system.  Suggest using a program such as Ccleaner to run at 
'login with the proper options set and the /AUTO option to clean user folders at login to 
'clean all user temp files.  There is really no good safe way to clean all user temp files
'on a system for all users profiles at this time.  Can write a a custom .NET app to do it, 
'but there is always great Risk if a setting is off of deleting needed folders...


'******************************************************************************************
'************************************ DiskCleanUp.vbs v1.0  *******************************
'****************************      Written By: Chris Reid      ****************************
'****************************       Date: July 21st, 2009       ***************************
'****************************   Copyright N-able Technologies  ****************************
'***  WARNING: This script should only be run by a Microsoft certified Administrator   ****
'***   N-able Technologies presents this script AS-IS - use at your own discretion      ***
'******************************************************************************************

'Description
'The purpose of this script is to clear out temporary files by running Microsoft's Windows Disk Cleanup (cleanmgr.exe) application.
'By default, this script will run against all drives (local and network) attached to the device
'Information on how to run Disk Cleanup from the command line was handily provided by the following Microsoft KB article: http://support.microsoft.com/kb/315246

'******************************************************************************************
Function RunDiskCleanup(strDeviceId)
'Let's declare some variables
 Dim Shell
 Dim CleaupCommand

 CleanupCommand = "cmd /c cleanmgr.exe /d " & strDeviceId & "\ /sagerun:1122"


 'Let's decide what options in Windows Disk Cleanup we want to run. We're going to create an overall job called 1122 (represented by StateFlags1122 in the registry).
 'A value of 2 turns that option on, and a value of 0 turns it off.
 'By default, all options have been enabled
 Set Shell = CreateObject("Wscript.Shell")
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Active Setup Temp Folders\StateFlags1122", 2, "REG_DWORD" 
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Content Indexer Cleaner\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Downloaded Program Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Hibernation File\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Internet Cache Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Memory Dump Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Microsoft Office Temp Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Offline Pages Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Old ChkDsk Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Previous Installations\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Recycle Bin\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Setup Log Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\System error memory dump files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\System error minidump files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Temporary Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Temporary Setup Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Temporary Sync Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Thumbnail Cache\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Upgrade Discarded Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Windows Error Reporting Archive Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Windows Error Reporting Queue Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Windows Error Reporting System Archive Files\StateFlags1122", 2, "REG_DWORD"
 Shell. RegWrite"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Windows Error Reporting System Queue Files\StateFlags1122", 2, "REG_DWORD"
 Set Shell = Nothing


 'Let's run the 1122 job by using the /sagerun:1122 flag
 'If you want to do it on a specific drive, run cleanmgr.exe /d C:\ /sagerun:1122
 Set Shell = CreateObject("Wscript.Shell")
 Shell.Run CleanupCommand ,7,TRUE
 Set Shell = Nothing


 'Having a tidy registry is a good thing. Let's delete the registry entries created by this script
 Set Shell = CreateObject("Wscript.Shell")
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Active Setup Temp Folders\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Content Indexer Cleaner\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Downloaded Program Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Hibernation File\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Internet Cache Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Memory Dump Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Microsoft Office Temp Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Offline Pages Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Old ChkDsk Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Previous Installations\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Recycle Bin\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Setup Log Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\System error memory dump files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\System error minidump files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Temporary Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Temporary Setup Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Temporary Sync Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Thumbnail Cache\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Upgrade Discarded Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Windows Error Reporting Archive Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Windows Error Reporting Queue Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Windows Error Reporting System Archive Files\StateFlags1122"
 Shell. RegDelete"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\VolumeCaches\Windows Error Reporting System Queue Files\StateFlags1122"
 Set Shell = Nothing
 RunDiskCleanup = CleanupCommand
End Function

' ****************************************************************************************
' Function to write results to WMI.  
' ****************************************************************************************
Function WriteResultsToWMI(strDrive, startTime, stopTime, fStart, fStop, bSuccess, cmdUsed, vbsScriptVersion, strFreeBefore, strFreeAfter, strCleanCommandUsed, strCheckDiskResults, strScriptReturnCode)
 'Create an instance of the class using SWbemObject.SpawnInstance
 Set objNewInst = GetObject("Winmgmts:root\" &uNameSpace & ":" & uClass).Spawninstance_
 objNewInst.DriveID = strDrive
 objNewInst.DefragStartTime = startTime
 objNewInst.DefragEndTime = stopTime
 objNewInst.FragPercentageBefore = int(fstart)
 objNewInst.FragPercentageAfter = int(fstop)
 objNewInst.LastRunSuccessful = bSuccess
 objNewInst.CommandUsed = cmdUsed
 objNewInst.DefragScriptVersion = vbsScriptVersion
 objNewInst.FreeSpaceBefore = strFreeBefore
 objNewInst.FreeSpaceAfter = strFreeAfter
 objNewInst.CleanupCommandUsed = strCleanCommandUsed
 objNewInst.CheckDiskResults = int(strCheckDiskResults)
 objNewInst.ScriptReturnCode = Int(strScriptReturnCode)
 objNewInst.DiskSpaceCleanedUp = Int(strFreeBefore) - Int(strFreeAfter)
 objNewInst.FragPercentEliminated = Int(fstart) - Int(fstop)

 ' Write the instance into the repository
 Set objInstancePath = objNewInst.Put_
End Function


' ****************************************************************************************
' Subrouting to Output Results to the Scrreen
' ****************************************************************************************
Sub WriteResults
Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\" & uNameSpace)
Set colDrives = objWMIService.ExecQuery("SELECT * FROM " & uClass)
Dim strResults
strResults = "WMI Contains Following Defrag Statistics: " & vbCrLf & "-------------------------------------------------------------------------" & vbCrLf 
For Each objDrive in colDrives
 strResults = strResults & _
 "DriveID: " & vbTab & vbTab & vbTab & objDrive.DriveID & vbCrLf & _
 "CheckDiskResults: " & vbTab & vbTab & objDrive.CheckDiskResults & vbCrLf & _
 "FragPercentageBefore: " & vbTab & vbTab & objDrive.FragPercentageBefore & vbCrLf & _
 "FragPercentageAfter: " & vbTab & vbTab & objDrive.FragPercentageAfter & vbCrLf & _
 "LastRunSuccessful: " & vbTab & vbTab & objDrive.LastRunSuccessful & vbCrLf & _
 "DefragStartTime: " & vbTab & vbTab & objDrive.DefragStartTime & vbCrLf & _
 "DefragStopTime: " & vbTab & vbTab & objDrive.DefragEndTime & vbCrLf & _
 "CommandUsed: " & vbTab & vbTab & vbTab & objDrive.CommandUsed & vbCrLf & _
 "FreeSpaceBefore: " & vbTab & vbTab & objDrive.FreeSpaceBefore & vbCrLf & _
 "FreeSpaceAfter: " & vbTab & vbTab & objDrive.FreeSpaceAfter & vbCrLf & _
 "CleanupCommandUsed: " & vbTab & vbTab & objDrive.CleanupCommandUsed & vbCrLf & _
 "DefragScriptVersion: " & vbTab & vbTab & objDrive.DefragScriptVersion & vbCrLf & _
 "ScriptReturnCode: " & vbTab & vbTab & objDrive.ScriptReturnCode & vbCrLf & _
 "DiskSpaceCleanedUp: " & vbTab & vbTab & objDrive.DiskSpaceCleanedUp & vbCrLf & _
 "FragPercentEliminated: " & vbTab & vbTab & objDrive.FragPercentEliminated & vbCrLf & _
 "-------------------------------------------------------------------------" & vbCrLf 
Next
Wscript.Echo strResults
End Sub


' ****************************************************************************************
' Primary program body
' ****************************************************************************************
bRemoveProfilesRun = True 'This is always true

' Check WMI for Namespaces and Class and Create / Recreate if Needed
If WMINamespaceExists = vbFalse Then
 Call CreateNameSpace
End If

If WMIClassExists = vbFalse Then
 Call CreateClass
ElseIf WMIClassVersionCurrent = vbFalse Then
 Call DeleteNameSpace
 Call CreateNameSpace
 Call CreateClass
End If

isSuccess = True
myDrives = GetDrives()

For Each strDrive in myDrives
 oTimeStart = Now()
 oFreeSpaceBefore = GetFreeSpace(strDrive)
 oCheckDiskResults = CheckDriveForErrors(strDrive)
 
 If oCheckDiskResults > 0 Then
   isSuccess = False
 End If
  
If bRunCleanup = True And oCheckDiskResults = 0 Then
 oCleanCommandUsed = RunDiskCleanup(strDrive)
 oFreeSpaceAfter = GetFreeSpace(strDrive)
Else
 oFreeSpaceAfter = oFreeSpaceBefore
 oCleanCommandUsed = "No Cleanup Performed on Last Run"
End If

If bCheckFragmentation = True And oCheckDiskResults = 0 And bRunDefragScript = False Then
  oBeforeResults = DefragAnalysis(strDrive)
  oFragStart = oBeforeResults(0)
  oFragStop = oBeforeResults(0)
  isSuccess = True
End If

If oCheckDiskResults = 0 And bRunDefragScript = True Then
	oBeforeResults = DefragAnalysis(strDrive)
 	oFragStart = oBeforeResults(0)
 	If oBeforeResults(1) = 1 Then
   		oDefragResults = RunDefrag(strDrive)
  		If oDefragResults(3) = "0" Then
   			oCommandUsed = oDefragResults(2)
   			oAfterResults = DefragAnalysis(strDrive)
   			oFragStop = oAfterResults(0)
   			isSuccess = True
  		Else
   			isSuccess = False
  		End If
	Else
  		oFragStop = oBeforeResults(0)
  		oCommandUsed = "No Defrag Performed"	
  		isSuccess = True
	End If 
ElseIf bRunDefragScript = False Then
	oCommandUsed = "No Defrag Performed on Last Run"
End If
	

 oTimeStop = Now()
 oScriptReturnCode = Err.Number
 
If oScriptReturnCode > 0 Then
	isSuccess = False
End If
 
Call WriteResultsToWMI(strDrive, oTimeStart, oTimeStop, oFragStart, oFragStop, isSuccess, oCommandUsed, strScriptVersion, oFreeSpaceBefore, oFreeSpaceAfter, oCleanCommandUsed, oCheckDiskResults, oScriptReturnCode)
Next

Call WriteResults

'*****************************************************************************************
' The code below is to read the values stored in WMI and output it to the screen.  Just copy
' and paste all the code below to a new .vbs file and save it and it should work just fine.
' Note:  If you change the namespace or class names in the primary script you will have to
' change those to the correct values. 
' ****************************************************************************************
'Dim strComputer
'strComputer = "."
'Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\NableEnhancements")
'Set colDrives = objWMIService.ExecQuery("SELECT * FROM Disk_Health")
'Dim strResults
'strResults = "WMI Contains Following Defrag Statistics: " & vbCrLf & "-------------------------------------------------------------------------" & vbCrLf 
'For Each objDrive in colDrives
' strResults = strResults & _
' "DriveID: " & vbTab & vbTab & vbTab & objDrive.DriveID & vbCrLf & _
' "CheckDiskResults: " & vbTab & vbTab & objDrive.CheckDiskResults & vbCrLf & _
' "FragPercentageBefore: " & vbTab & objDrive.FragPercentageBefore & vbCrLf & _
' "FragPercentageAfter: " & vbTab & objDrive.FragPercentageAfter & vbCrLf & _
' "LastRunSuccessful: " & vbTab & vbTab & objDrive.LastRunSuccessful & vbCrLf & _
' "DefragStartTime: " & vbTab & vbTab & objDrive.DefragStartTime & vbCrLf & _
' "DefragStopTime: " & vbTab & vbTab & objDrive.DefragEndTime & vbCrLf & _
' "CommandUsed: " & vbTab & vbTab & objDrive.CommandUsed & vbCrLf & _
' "FreeSpaceBefore: " & vbTab & vbTab & objDrive.FreeSpaceBefore & vbCrLf & _
' "FreeSpaceAfter: " & vbTab & vbTab & objDrive.FreeSpaceAfter & vbCrLf & _
' "CleanupCommandUsed: " & vbTab & objDrive.CleanupCommandUsed & vbCrLf & _
' "DefragScriptVersion: " & vbTab & vbTab & objDrive.DefragScriptVersion & vbCrLf & _
' "ScriptReturnCode: " & vbTab & vbTab & objDrive.ScriptReturnCode & vbCrLf & _
' "DiskSpaceCleanedUp: " & vbTab & objDrive.DiskSpaceCleanedUp & vbCrLf & _
' "FragPercentEliminated: " & vbTab & objDrive.FragPercentEliminated & vbCrLf & _
' "-------------------------------------------------------------------------" & vbCrLf  
'Next
'Wscript.Echo strResults

